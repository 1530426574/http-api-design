{"name":"HTTP API Design Guide","tagline":"HTTP API design guide extracted from work on the Heroku Platform API.","body":"## Introduction\r\n\r\nThis guide describes a set of HTTP+JSON API design practices, originally\r\nextracted from work on the [Heroku Platform API](https://devcenter.heroku.com/articles/platform-api-reference).\r\n\r\nThis guide informs additions to that API and also guides new internal\r\nAPIs at Heroku. We hope it’s also of interest to API designers\r\noutside of Heroku.\r\n\r\nOur goals here are consistency and focusing on business logic while\r\navoiding design bikeshedding. We’re looking for _a good, consistent,\r\nwell-documented way_ to design APIs, not necessarily _the only/ideal\r\nway_.\r\n\r\nWe assume you’re familiar with the basics of HTTP+JSON APIs and won’t\r\ncover all of the fundamentals of those in this guide.\r\n\r\nWe welcome [contributions](CONTRIBUTING.md) to this guide.\r\n\r\n## Contents\r\n\r\n*  [Return appropriate status codes](#return-appropriate-status-codes)\r\n*  [Provide full resources where available](#provide-full-resources-where-available)\r\n*  [Accept serialized JSON in request bodies](#accept-serialized-json-in-request-bodies)\r\n*  [Provide resource (UU)IDs](#provide-resource-uuids)\r\n*  [Provide standard timestamps](#provide-standard-timestamps)\r\n*  [Use UTC times formatted in ISO8601](#use-utc-times-formatted-in-iso8601)\r\n*  [Use consistent path formats](#use-consistent-path-formats)\r\n*  [Downcase paths and attributes](#downcase-paths-and-attributes)\r\n*  [Nest foreign key relations](#nest-foreign-key-relations)\r\n*  [Support non-id dereferencing for convenience](#support-non-id-dereferencing-for-convenience)\r\n*  [Generate structured errors](#generate-structured-errors)\r\n*  [Support caching with Etags](#support-caching-with-etags)\r\n*  [Trace requests with Request-Ids](#trace-requests-with-request-ids)\r\n*  [Paginate with ranges](#paginate-with-ranges)\r\n*  [Show rate limit status](#show-rate-limit-status)\r\n*  [Version with Accepts header](#version-with-accepts-header)\r\n*  [Provide machine-readable JSON schema](#provide-machine-readable-json-schema)\r\n*  [Provide human-readable docs](#provide-human-readable-docs)\r\n*  [Provide executable examples](#provide-executable-examples)\r\n*  [Describe stability](#describe-stability)\r\n*  [Require TLS](#require-tls)\r\n*  [Pretty-print JSON by default](#pretty-print-json-by-default)\r\n\r\n### Return appropriate status codes\r\n\r\nReturn appropriate HTTP status codes with each response. Successful\r\nresponses should be coded according to this guide:\r\n\r\n* `200`: Request succeeded for a `GET` calls, and for `DELETE` or\r\n  `PATCH` calls that complete synchronously\r\n* `201`: Request succeeded for a `POST` call that completes\r\n  synchronously\r\n* `202`: Request accepted for a `POST`, `DELETE`, or `PATCH` call that\r\n  will be processed asynchronously\r\n* `206`: Request succeeded on `GET`, but only a partial response\r\n  returned: see [above on ranges](#paginate-with-ranges)\r\n\r\nRefer to the [HTTP response code spec](http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html)\r\nfor guidance on status codes for user error and server error cases.\r\n\r\n### Provide full resources where available\r\n\r\nProvide the full resource representation (i.e. the object with all\r\nattributes) whenever possible in the response. Always provide the full\r\nresource on 200 and 201 responses, including `PUT`/`PATCH` and `DELETE`\r\nrequests, e.g.:\r\n\r\n```\r\n$ curl -X DELETE \\  \r\n  https://service.com/apps/1f9b/domains/0fd4\r\n\r\nHTTP/1.1 200 OK\r\nContent-Type: application/json;charset=utf-8\r\n...\r\n{\r\n  \"created_at\": \"2012-01-01T12:00:00Z\",\r\n  \"hostname\": \"subdomain.example.com\",\r\n  \"id\": \"01234567-89ab-cdef-0123-456789abcdef\",\r\n  \"updated_at\": \"2012-01-01T12:00:00Z\"\r\n}\r\n```\r\n\r\n202 responses will not include the full resource representation,\r\ne.g.:\r\n\r\n```\r\n$ curl -X DELETE \\  \r\n  https://service.com/apps/1f9b/dynos/05bd\r\n\r\nHTTP/1.1 202 Accepted\r\nContent-Type: application/json;charset=utf-8\r\n...\r\n{}\r\n```\r\n\r\n### Accept serialized JSON in request bodies\r\n\r\nAccept serialized JSON on `PUT`/`PATCH`/`POST` request bodies, either\r\ninstead of or in addition to form-encoded data. This creates symmetry\r\nwith JSON-serialized response bodies, e.g.:\r\n\r\n```\r\n$ curl -X POST https://service.com/apps \\\r\n    -H \"Content-Type: application/json\" \\\r\n    -d '{\"name\": \"demoapp\"}'\r\n\r\n{\r\n  \"id\": \"01234567-89ab-cdef-0123-456789abcdef\",\r\n  \"name\": \"demoapp\",\r\n  \"owner\": {\r\n    \"email\": \"username@example.com\",\r\n    \"id\": \"01234567-89ab-cdef-0123-456789abcdef\"\r\n  },\r\n  ...\r\n}\r\n```\r\n\r\n### Provide resource (UU)IDs\r\n\r\nGive each resource an `id` attribute by default. Use UUIDs unless you\r\nhave a very good reason not to. Don’t use IDs that won’t be globally\r\nunique across instances of the service or other resources in the\r\nservice, especially auto-incrementing IDs.\r\n\r\nRender UUIDs in downcased `8-4-4-4-12` format, e.g.:\r\n\r\n```\r\n\"id\": \"01234567-89ab-cdef-0123-456789abcdef\"\r\n```\r\n\r\n### Provide standard timestamps\r\n\r\nProvide `created_at` and `updated_at` timestamps for resources by default,\r\ne.g:\r\n\r\n```json\r\n{\r\n  ...\r\n  \"created_at\": \"2012-01-01T12:00:00Z\",\r\n  \"updated_at\": \"2012-01-01T13:00:00Z\",\r\n  ...\r\n}\r\n```\r\n\r\nThese timestamps may not make sense for some resources, in which case\r\nthey can be omitted.\r\n\r\n### Use UTC times formatted in ISO8601\r\n\r\nAccept and return times in UTC only. Render times in ISO8601 format,\r\ne.g.:\r\n\r\n```\r\n\"finished_at\": \"2012-01-01T12:00:00Z\"\r\n```\r\n\r\n### Use consistent path formats\r\n\r\n#### Resource names\r\n\r\nUse the plural version of a resource name unless the resource in question is a singleton within the system (for example, in most systems a given user would only ever have one account). This keeps it consistent in the way you refer to particular resources.\r\n\r\n#### Actions\r\n\r\nPrefer endpoint layouts that don’t need any special actions for\r\nindividual resources. In cases where special actions are needed, place\r\nthem under a standard `actions` prefix, to clearly delineate them:\r\n\r\n```\r\n/resources/:resource/actions/:action\r\n```\r\n\r\ne.g.\r\n\r\n```\r\n/runs/{run_id}/actions/stop\r\n```\r\n\r\n### Downcase paths and attributes\r\n\r\nUse downcased and dash-separated path names, for alignment with\r\nhostnames, e.g:\r\n\r\n```\r\nservice-api.com/users\r\nservice-api.com/app-setups\r\n```\r\n\r\nDowncase attributes as well, but use underscore separators so that\r\nattribute names can be typed without quotes in JavaScript, e.g.:\r\n\r\n```\r\nservice_class: \"first\"\r\n```\r\n\r\n### Nest foreign key relations\r\n\r\nSerialize foreign key references with a nested object, e.g.:\r\n\r\n```json\r\n{\r\n  \"name\": \"service-production\",\r\n  \"owner\": {\r\n    \"id\": \"5d8201b0...\"\r\n  },\r\n  ...\r\n}\r\n```\r\n  \r\nInstead of e.g:\r\n\r\n```json\r\n{\r\n  \"name\": \"service-production\",\r\n  \"owner_id\": \"5d8201b0...\",\r\n  ...\r\n}\r\n```\r\n\r\nThis approach makes it possible to inline more information about the\r\nrelated resource without having to change the structure of the response\r\nor introduce more top-level response fields, e.g.:\r\n\r\n```json\r\n{\r\n  \"name\": \"service-production\",\r\n  \"owner\": {\r\n    \"id\": \"5d8201b0...\",\r\n    \"name\": \"Alice\",\r\n    \"email\": \"alice@heroku.com\"\r\n  },\r\n  ...\r\n}\r\n```\r\n\r\n### Support non-id dereferencing for convenience\r\n\r\nIn some cases it may be inconvenient for end-users to provide IDs to\r\nidentify a resource. For example, a user may think in terms of a Heroku\r\napp name, but that app may be identified by a UUID. In these cases you\r\nmay want to accept both an id or name, e.g.:\r\n\r\n```\r\n$ curl https://service.com/apps/{app_id_or_name}\r\n$ curl https://service.com/apps/97addcf0-c182\r\n$ curl https://service.com/apps/www-prod\r\n```\r\n\r\nDo not accept only names to the exclusion of IDs.\r\n\r\n### Generate structured errors\r\n\r\nGenerate consistent, structured response bodies on errors. Include a\r\nmachine-readable error `id`, a human-readable error `message`, and\r\noptionally a `url` pointing the client to further information about the\r\nerror and how to resolve it, e.g.:\r\n\r\n```\r\nHTTP/1.1 429 Too Many Requests\r\n```\r\n\r\n```json\r\n{\r\n  \"id\":      \"rate_limit\",\r\n  \"message\": \"Account reached its API rate limit.\",\r\n  \"url\":     \"https://docs.service.com/rate-limits\"\r\n}\r\n```\r\n\r\nDocument your error format and the possible error `id`s that clients may\r\nencounter.\r\n\r\n### Support caching with Etags\r\n\r\nInclude an `ETag` header in all responses, identifying the specific\r\nversion of the returned resource. The user should be able to check for\r\nstaleness in their subsequent requests by supplying the value in the\r\n`If-None-Match` header.\r\n\r\n### Trace requests with Request-Ids\r\n\r\nInclude a `Request-Id` header in each API response, populated with a\r\nUUID value. If both the server and client log these values, it will be\r\nhelpful for tracing and debugging requests.\r\n\r\n### Paginate with Ranges\r\n\r\nPaginate any responses that are liable to produce large amounts of data.\r\nUse `Content-Range` headers to convey pagination requests. Follow the\r\nexample of the [Heroku Platform API on Ranges](https://devcenter.heroku.com/articles/platform-api-reference#ranges)\r\nfor the details of request and response headers, status codes, limits,\r\nordering, and page-walking.\r\n\r\n### Show rate limit status\r\n\r\nRate limit requests from clients to protect the health of the service\r\nand maintain high service quality for other clients. You can use a\r\n[token bucket algorithm](http://en.wikipedia.org/wiki/Token_bucket) to\r\nquantify request limits.\r\n\r\nReturn the remaining number of request tokens with each request in the\r\n`RateLimit-Remaining` response header.\r\n\r\n### Version with Accepts header\r\n\r\nVersion the API from the start. Use the `Accepts` header to communicate\r\nthe version, along with a custom content type, e.g.:\r\n\r\n```\r\nAccept: application/vnd.heroku+json; version=3\r\n```\r\n\r\nPrefer not to have a default version, instead requiring clients to\r\nexplicitly peg their usage to a specific version.\r\n\r\n### Minimize path nesting\r\n\r\nIn data models with nested parent/child resource relationships, paths\r\nmay become deeply nested, e.g.:\r\n\r\n```\r\n/orgs/{org_id}/apps/{app_id}/dynos/{dyno_id}\r\n```\r\n\r\nLimit nesting depth by preferring to locate resources at the root\r\npath. Use nesting to indicate scoped collections. For example, for the\r\ncase above where a dyno belongs to an app belongs to an org:\r\n\r\n```\r\n/orgs/{org_id}\r\n/orgs/{org_id}/apps\r\n/apps/{app_id}\r\n/apps/{app_id}/dynos\r\n/dynos/{dyno_id}\r\n```\r\n\r\n### Provide machine-readable JSON schema\r\n\r\nProvide a machine-readable schema to exactly specify your API. Use\r\n[prmd](https://github.com/interagent/prmd) to manage your schema, and ensure\r\nit validates with `prmd verify`.\r\n\r\n### Provide human-readable docs\r\n\r\nProvide human-readable documentation that client developers can use to\r\nunderstand your API.\r\n\r\nIf you create a schema with prmd as described above, you can easily\r\ngenerate Markdown docs for all endpoints with with `prmd doc`.\r\n\r\nIn addition to endpoint details, provide an API overview with\r\ninformation about:\r\n\r\n* Authentication, including acquiring and using authentication tokens.\r\n* API stability and versioning, including how to select the desired API\r\n  version.\r\n* Common request and response headers.\r\n* Error serialization format.\r\n* Examples of using the API with clients in different languages.\r\n\r\n### Provide executable examples\r\n\r\nProvide executable examples that users can type directly into their\r\nterminals to see working API calls. To the greatest extent possible,\r\nthese examples should be usable verbatim, to minimize the amount of\r\nwork a user needs to do to try the API, e.g.:\r\n\r\n```\r\n$ export TOKEN=... # acquire from dashboard\r\n$ curl -is https://$TOKEN@service.com/users\r\n```\r\n\r\nIf you use [prmd](https://github.com/interagent/prmd) to generate Markdown\r\ndocs, you will get examples for each endpoint for free.\r\n\r\n### Describe stability\r\n\r\nDescribe the stability of your API or its various endpoints according to\r\nits maturity and stability, e.g. with prototype/development/production\r\nflags.\r\n\r\nSee the [Heroku API compatibility policy](https://devcenter.heroku.com/articles/api-compatibility-policy)\r\nfor a possible stability and change management approach.\r\n\r\nOnce your API is declared production-ready and stable, do not make\r\nbackwards incompatible changes within that API version. If you need to\r\nmake backwards-incompatible changes, create a new API with an\r\nincremented version number.\r\n\r\n### Require TLS\r\n\r\nRequire TLS to access the API, without exception. It’s not worth trying\r\nto figure out or explain when it is OK to use TLS and when it’s not.\r\nJust require TLS for everything.\r\n\r\n### Pretty-print JSON by default\r\n\r\nThe first time a user sees your API is likely to be at the command line,\r\nusing curl. It’s much easier to understand API responses at the\r\ncommand-line if they are pretty-printed. For the convenience of these\r\ndevelopers, pretty-print JSON responses, e.g.:\r\n\r\n```json\r\n{\r\n  \"beta\": false,\r\n  \"email\": \"alice@heroku.com\",\r\n  \"id\": \"01234567-89ab-cdef-0123-456789abcdef\",\r\n  \"last_login\": \"2012-01-01T12:00:00Z\",\r\n  \"created_at\": \"2012-01-01T12:00:00Z\",\r\n  \"updated_at\": \"2012-01-01T12:00:00Z\"\r\n}\r\n```\r\n\r\nInstead of e.g.:\r\n\r\n```json\r\n{\"beta\":false,\"email\":\"alice@heroku.com\",\"id\":\"01234567-89ab-cdef-0123-456789abcdef\",\"last_login\":\"2012-01-01T12:00:00Z\", \"created_at\":\"2012-01-01T12:00:00Z\",\"updated_at\":\"2012-01-01T12:00:00Z\"}\r\n```\r\n\r\nBe sure to include a trailing newline so that the user’s terminal prompt\r\nisn’t obstructed.\r\n\r\nFor most APIs it will be fine performance-wise to pretty-print responses\r\nall the time. You may consider for performance-sensitive APIs not\r\npretty-printing certain endpoints (e.g. very high traffic ones) or not\r\ndoing it for certain clients (e.g. ones known to be used by headless\r\nprograms).\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}